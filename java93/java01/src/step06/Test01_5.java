/* class 문법의 용도: 사용자 정의 데이터 타입 만들기V
 * => 인스턴스의 변수 값을 다루는 메서드는 
 *    반드시 인스턴스가 파라미터로 주어져야 한다.
 * => 인스턴스를 파라미터로 넘기지 않고 더 편리하게 전달하는 문법이 있다.
 *    그 문법이 "인스턴스 메서드"이다.
 * => 인스턴스 메서드는 static을 붙이지 않는다.
 *    static(정적인)?
 *      => 즉 인스턴스에 대해 메서드를 호출하는 방식이 고정되었다는 뜻이다.
 *      => static이 붙은 메서드의 호출 방식
 *         예) 클래스명.메서드명()
 *    static을 붙이지 않는다는 것?
 *      => 인스턴스 마다 메서드를 호출하는 방식이 다르다는 뜻이다.
 *      => static이 붙지 않은 메서드의 호출 방식
 *         예) 인스턴스주소.메서드명()
 */
package step06;

public class Test01_5 {
  

  public static void main(String[] args) {
    Student2 s1 = new Student2();
    // 인스턴스 메서드를 호출할 때는 반드시 인스턴스 주소를 앞에 놓아야한다.
    // => 메서드 이름앞에 인스턴스 주소가 놓임으로써
    //    메서드가 그 인스턴스에 대해 동작할 것임을 직관적임을 보여준다.
    // => 메서드를 호출하는 모양이
    //    i ++;
    //    처럼 변수에 대해 연산자를 사용하는 것과 같다고 해서
    //    인스턴스 메서드를 "인스턴스 연산자(operator)"라고도 한다.
    //    즉, 사용자가 새롭게 정의한 타입의 
    //    "데이터를 다루는 연산자"라 볼 수 있다.
    s1.init("홍길동", 100, 100, 100); // 클래스가 아니라 인스턴스 주소를 놓아야한다. Student(x)
    s1.compute();
    
    Student2 s2 = new Student2();
    s2.init("임꺽정", 90, 90, 90);
    s2.compute();
    
    Student2 s3 = new Student2();
    s3.init("유관순", 80, 80, 80);
    s3.compute();
    
    s1.print();
    s2.print();
    s3.print();
    
  }

}
